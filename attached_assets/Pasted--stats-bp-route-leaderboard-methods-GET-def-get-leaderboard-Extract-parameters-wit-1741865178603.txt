@stats_bp.route('/leaderboard', methods=['GET'])
def get_leaderboard():
    # Extract parameters with defaults
    period = request.args.get('period', 'all-time')

    # Handle non-integer page values safely
    try:
        page = int(request.args.get('page', 1))
    except (ValueError, TypeError):
        # If page isn't a valid number, default to page 1
        page = 1

    try:
        per_page = min(int(request.args.get('per_page', 10)),
                       50)  # Limit to 50 max
    except (ValueError, TypeError):
        # If per_page isn't a valid number, default to 10
        per_page = 10

    # Calculate pagination offset
    offset = (page - 1) * per_page

    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()

            # Get the requesting user's ID (if authenticated)
            auth_header = request.headers.get('Authorization')
            user_id = None

            if auth_header and auth_header.startswith('Bearer '):
                token = auth_header.split(' ')[1]
                try:
                    user_id = validate_token(token)
                except ValueError:
                    # Continue anyway, just won't have user-specific data
                    pass

            # If no token, try session
            if not user_id:
                user_id = session.get('user_id')

            # Define the time filter condition
            time_filter = ""
            time_filter_params = []

            # Modify query based on requested period
            if period == 'weekly':
                # Get start of current week (Monday)
                today = datetime.datetime.now().date()
                start_of_week = today - datetime.timedelta(
                    days=today.weekday())
                time_filter = "AND date(g.created_at) >= date(?)"
                time_filter_params = [start_of_week.isoformat()]

            # Base query for top entries
            if period == 'weekly':
                # If weekly, we need to calculate from game_scores
                top_entries_query = '''
                    SELECT 
                        u.username, 
                        u.user_id,
                        SUM(g.score) as total_score,
                        COUNT(g.id) as games_played,
                        AVG(g.score) as avg_score,
                        u.user_id = ? as is_current_user,
                        RANK() OVER (ORDER BY SUM(g.score) DESC) as rank
                    FROM game_scores g
                    JOIN users u ON g.user_id = u.user_id
                    WHERE g.completed = 1
                '''

                if time_filter:
                    top_entries_query += " " + time_filter

                top_entries_query += '''
                    GROUP BY g.user_id
                    ORDER BY total_score DESC
                    LIMIT ? OFFSET ?
                '''
                top_entries_params = [user_id] + time_filter_params + [
                    per_page, offset
                ]
            else:
                # For all-time, use the user_stats table which has precomputed values
                top_entries_query = '''
                    SELECT 
                        u.username, 
                        u.user_id,
                        s.cumulative_score as total_score,
                        s.total_games_played as games_played,
                        CASE 
                            WHEN s.total_games_played > 0 THEN s.cumulative_score / s.total_games_played 
                            ELSE 0 
                        END as avg_score,
                        u.user_id = ? as is_current_user,
                        RANK() OVER (ORDER BY s.cumulative_score DESC) as rank
                    FROM user_stats s
                    JOIN users u ON s.user_id = u.user_id
                    ORDER BY total_score DESC
                    LIMIT ? OFFSET ?
                '''
                top_entries_params = [user_id, per_page, offset]

            # Execute query for top leaderboard entries
            cursor.execute(top_entries_query, top_entries_params)
            top_entries = []
            for row in cursor.fetchall():
                top_entries.append({
                    "rank":
                    row['rank'],
                    "username":
                    row['username'],
                    "user_id":
                    row['user_id'],
                    "score":
                    row['total_score'],
                    "games_played":
                    row['games_played'],
                    "avg_score":
                    round(row['avg_score'], 1) if row['avg_score'] else 0,
                    "is_current_user":
                    bool(row['is_current_user'])
                })

            # Get current user entry if authenticated and not in top entries
            current_user_entry = None
            if user_id and not any(entry['is_current_user']
                                   for entry in top_entries):
                if period == 'weekly':
                    user_query = '''
                        SELECT 
                            u.username, 
                            u.user_id,
                            SUM(g.score) as total_score,
                            COUNT(g.id) as games_played,
                            AVG(g.score) as avg_score,
                            RANK() OVER (ORDER BY SUM(g.score) DESC) as rank
                        FROM game_scores g
                        JOIN users u ON g.user_id = u.user_id
                        WHERE g.completed = 1
                        AND u.user_id = ?
                    '''
                    if time_filter:
                        user_query += " " + time_filter.replace('g.', '')
                    user_query += " GROUP BY g.user_id"
                    user_params = [user_id] + time_filter_params
                else:
                    # For all-time, get from user_stats
                    user_query = '''
                        WITH RankedUsers AS (
                            SELECT 
                                u.user_id,
                                u.username,
                                s.cumulative_score as total_score,
                                s.total_games_played as games_played,
                                CASE 
                                    WHEN s.total_games_played > 0 THEN s.cumulative_score / s.total_games_played 
                                    ELSE 0 
                                END as avg_score,
                                RANK() OVER (ORDER BY s.cumulative_score DESC) as rank
                            FROM user_stats s
                            JOIN users u ON s.user_id = u.user_id
                        )
                        SELECT * FROM RankedUsers WHERE user_id = ?
                    '''
                    user_params = [user_id]

                cursor.execute(user_query, user_params)
                user_row = cursor.fetchone()

                if user_row:
                    current_user_entry = {
                        "rank":
                        user_row['rank'],
                        "username":
                        user_row['username'],
                        "user_id":
                        user_row['user_id'],
                        "score":
                        user_row['total_score'],
                        "games_played":
                        user_row['games_played'],
                        "avg_score":
                        round(user_row['avg_score'], 1)
                        if user_row['avg_score'] else 0,
                        "is_current_user":
                        True
                    }

            # Get total number of entries for pagination info
            if period == 'weekly':
                count_query = '''
                    SELECT COUNT(DISTINCT g.user_id) as total_users
                    FROM game_scores g
                    JOIN users u ON g.user_id = u.user_id
                    WHERE g.completed = 1
                '''

                if time_filter:
                    count_query += " " + time_filter

                cursor.execute(count_query, time_filter_params)
            else:
                # For all-time, count from user_stats
                count_query = 'SELECT COUNT(*) as total_users FROM user_stats'
                cursor.execute(count_query)

            total_users = cursor.fetchone()['total_users']

            # Prepare pagination info
            pagination = {
                "current_page":
                page,
                "total_pages": (total_users + per_page - 1) //
                per_page if total_users > 0 else 1,
                "total_entries":
                total_users,
                "per_page":
                per_page
            }

            # Return results in the new format
            return jsonify({
                "topEntries": top_entries,
                "currentUserEntry": current_user_entry,
                "pagination": pagination,
                "period": period
            })

    except Exception as e:
        logging.error(f"Error fetching leaderboard: {e}")
        return jsonify({"error": "Failed to retrieve leaderboard data"}), 500